"""Contract: execution plans produced by cacp conform to gitops-config schema.

This is the **critical governance test**.  If this fails, it means the
control-plane would generate PRs that clinic-gitops-config would reject.

The test exercises the real `build_execution_plan()` + `sign_payload()`
pipeline and validates the output against the authoritative JSON Schema
from clinic-gitops-config.
"""

from __future__ import annotations

from typing import Any

import jsonschema
import pytest

from cacp.gitops.manifest import build_execution_plan
from cacp.orchestration.orchestrator import Orchestrator
from cacp.settings import Settings
from cacp.signing.hmac import sign_payload
from cacp.storage.event_store import InMemoryEventStore


# ── Helpers ─────────────────────────────────────────────────────


def _build_signed_plan(
    appointment: dict[str, Any],
    result: Any,
    secret: str,
    environment: str = "dev",
) -> dict[str, Any]:
    """Reconstruct and sign the plan exactly as the orchestrator does."""
    plan = build_execution_plan(
        proposal_id=result.proposal_id,
        clinic_id=appointment["clinic_id"],
        patient_id=appointment["patient_id"],
        appointment_id=appointment["appointment_id"],
        actions=result.actions,
        risk_level=result.risk_level,
        environment=environment,
    )
    plan["hmac_signature"] = sign_payload(plan, secret)
    return plan


_SECRET = "contract-test-secret-do-not-use"


def _settings() -> Settings:
    return Settings(
        hmac_secret=_SECRET,
        github_token="",
        environment="dev",
        opa_url="",
    )


# ── Canonical test appointments ─────────────────────────────────


_HIGH_RISK = {
    "appointment_id": "CT-APT-001",
    "patient_id": "CT-PAT-001",
    "clinic_id": "CT-CLINIC-A",
    "scheduled_at": "2026-04-10T08:00:00+00:00",
    "treatment_type": "endodoncia",
    "is_first_visit": True,
    "previous_no_shows": 4,
    "patient_phone": "+34600000001",
    "patient_whatsapp": True,
    "consent_given": True,
}

_LOW_RISK = {
    "appointment_id": "CT-APT-002",
    "patient_id": "CT-PAT-002",
    "clinic_id": "CT-CLINIC-A",
    "scheduled_at": "2026-04-10T10:00:00+00:00",
    "treatment_type": "limpieza",
    "is_first_visit": False,
    "previous_no_shows": 0,
    "patient_phone": "+34600000002",
    "patient_whatsapp": True,
    "consent_given": True,
}


# ── Contract tests ──────────────────────────────────────────────


class TestPlanConformsToGitopsSchema:
    """Plans generated by cacp MUST validate against gitops-config schema."""

    @pytest.mark.anyio
    async def test_high_risk_plan_valid(
        self, gitops_execution_plan_schema: dict[str, Any]
    ) -> None:
        orchestrator = Orchestrator(
            settings=_settings(), github_pr=None, event_store=InMemoryEventStore()
        )
        result = await orchestrator.process_appointment(_HIGH_RISK)
        plan = _build_signed_plan(_HIGH_RISK, result, _SECRET)

        jsonschema.validate(instance=plan, schema=gitops_execution_plan_schema)

    @pytest.mark.anyio
    async def test_low_risk_plan_valid(
        self, gitops_execution_plan_schema: dict[str, Any]
    ) -> None:
        orchestrator = Orchestrator(
            settings=_settings(), github_pr=None, event_store=InMemoryEventStore()
        )
        result = await orchestrator.process_appointment(_LOW_RISK)
        plan = _build_signed_plan(_LOW_RISK, result, _SECRET)

        jsonschema.validate(instance=plan, schema=gitops_execution_plan_schema)

    @pytest.mark.anyio
    async def test_plan_has_required_fields(
        self, gitops_execution_plan_schema: dict[str, Any]
    ) -> None:
        """Explicitly assert required fields are present (belt and suspenders)."""
        orchestrator = Orchestrator(
            settings=_settings(), github_pr=None, event_store=InMemoryEventStore()
        )
        result = await orchestrator.process_appointment(_HIGH_RISK)
        plan = _build_signed_plan(_HIGH_RISK, result, _SECRET)

        required = gitops_execution_plan_schema.get("required", [])
        for field in required:
            assert field in plan, f"Missing required field: {field}"

    @pytest.mark.anyio
    async def test_each_action_has_required_fields(
        self, gitops_execution_plan_schema: dict[str, Any]
    ) -> None:
        """Each action in the plan must conform to the action $def."""
        orchestrator = Orchestrator(
            settings=_settings(), github_pr=None, event_store=InMemoryEventStore()
        )
        result = await orchestrator.process_appointment(_HIGH_RISK)
        plan = _build_signed_plan(_HIGH_RISK, result, _SECRET)

        action_schema = gitops_execution_plan_schema.get("$defs", {}).get("action", {})
        action_required = action_schema.get("required", [])

        for i, action in enumerate(plan["actions"]):
            for field in action_required:
                assert field in action, f"Action [{i}] missing required field: {field}"

    @pytest.mark.anyio
    async def test_plan_rejects_invalid_environment(
        self, gitops_execution_plan_schema: dict[str, Any]
    ) -> None:
        """An environment not in the enum should fail validation."""
        orchestrator = Orchestrator(
            settings=Settings(
                hmac_secret=_SECRET,
                github_token="",
                environment="staging",  # not in enum [dev, prod]
                opa_url="",
            ),
            github_pr=None,
            event_store=InMemoryEventStore(),
        )
        result = await orchestrator.process_appointment(_HIGH_RISK)
        plan = _build_signed_plan(_HIGH_RISK, result, _SECRET, environment="staging")

        with pytest.raises(jsonschema.ValidationError):
            jsonschema.validate(instance=plan, schema=gitops_execution_plan_schema)


class TestSchemaDrift:
    """Detect structural drift between cacp's local schemas and gitops-config.

    If the gitops-config repo changes its schema in a breaking way,
    these tests will catch it before a broken PR is opened.
    """

    def test_gitops_schema_has_actions_array(
        self, gitops_execution_plan_schema: dict[str, Any]
    ) -> None:
        props = gitops_execution_plan_schema.get("properties", {})
        assert "actions" in props
        assert props["actions"]["type"] == "array"

    def test_gitops_schema_has_hmac_field(
        self, gitops_execution_plan_schema: dict[str, Any]
    ) -> None:
        props = gitops_execution_plan_schema.get("properties", {})
        assert "hmac_signature" in props

    def test_action_types_match_revenue_agent(
        self, gitops_execution_plan_schema: dict[str, Any]
    ) -> None:
        """The action_type enum in gitops must include all types revenue_agent generates."""
        action_def = gitops_execution_plan_schema.get("$defs", {}).get("action", {})
        action_type_enum = (
            action_def.get("properties", {}).get("action_type", {}).get("enum", [])
        )
        # Revenue agent generates these types
        expected = {"send_reminder", "send_confirmation", "reschedule"}
        assert expected.issubset(set(action_type_enum)), (
            f"gitops schema action_type enum {action_type_enum} "
            f"missing types generated by revenue agent: {expected - set(action_type_enum)}"
        )

    def test_channel_enum_match(
        self, gitops_execution_plan_schema: dict[str, Any]
    ) -> None:
        """Channel enum in gitops must include all channels revenue_agent uses."""
        action_def = gitops_execution_plan_schema.get("$defs", {}).get("action", {})
        channel_enum = (
            action_def.get("properties", {}).get("channel", {}).get("enum", [])
        )
        expected = {"whatsapp", "sms"}
        assert expected.issubset(set(channel_enum)), (
            f"gitops schema channel enum {channel_enum} "
            f"missing channels used by revenue agent: {expected - set(channel_enum)}"
        )
